diff --git a/dist/libraries/handlebars/asyncHandlebars.js b/dist/libraries/handlebars/asyncHandlebars.js
index 3a8e7a61b1c3391b9f4ace359b8767e94c717e08..0cff67e63a77ff7921baeea069186d93a9721f33 100644
--- a/dist/libraries/handlebars/asyncHandlebars.js
+++ b/dist/libraries/handlebars/asyncHandlebars.js
@@ -1,5 +1,101 @@
-import Handlebars from 'handlebars/dist/handlebars.js';
-import asyncHelpers from 'handlebars-async-helpers';
-export const asyncHandlebars = asyncHelpers(Handlebars);
+/**
+ * CF Workers-compatible replacement for Handlebars + handlebars-async-helpers.
+ * Uses Mustache for template rendering (no eval/new Function).
+ * Provides a compatible API surface (compile, SafeString, registerHelper).
+ */
+import Mustache from 'mustache';
+
+// Store registered helpers
+const _helpers = {};
+
+// SafeString wrapper — just wraps a string to mark it as "safe" (no escaping)
+class SafeString {
+  constructor(str) {
+    this.string = str;
+  }
+  toString() {
+    return this.string;
+  }
+}
+
+/**
+ * Async-aware compile that handles helpers like {{toHTML fieldName}}.
+ * Handlebars helpers use {{helperName arg}} syntax, which Mustache doesn't support.
+ * We pre-process helper calls before passing to Mustache.
+ */
+function compile(template, options) {
+  return async function(context) {
+    let processed = template;
+
+    // Pre-process helper calls: {{helperName arg}} → resolve helper, inject result
+    for (const [name, fn] of Object.entries(_helpers)) {
+      // Match {{helperName arg}} patterns (with optional whitespace)
+      const helperRegex = new RegExp(`\\{\\{\\s*${name}\\s+(\\w+)\\s*\\}\\}`, 'g');
+      const matches = [...processed.matchAll(helperRegex)];
+      for (const match of matches) {
+        const argName = match[1];
+        const argValue = context && typeof context === 'object' ? context[argName] : undefined;
+        // Resolve the value (might be a SafeString proxy promise)
+        const resolvedValue = await Promise.resolve(argValue);
+        const raw = resolvedValue instanceof SafeString ? resolvedValue.toString() :
+                    (resolvedValue && typeof resolvedValue === 'object' && resolvedValue.string !== undefined) ? resolvedValue.string :
+                    (typeof resolvedValue === 'string' ? resolvedValue : '');
+        try {
+          // Call the helper with the resolved value
+          const helperResult = await fn.call(context, raw, { ids: [argName] });
+          const resultStr = helperResult instanceof SafeString ? helperResult.toString() :
+                           (helperResult && typeof helperResult === 'object' && helperResult.string !== undefined) ? helperResult.string :
+                           String(helperResult ?? '');
+          processed = processed.replace(match[0], resultStr);
+        } catch (e) {
+          // If helper fails, just use the raw value
+          processed = processed.replace(match[0], raw);
+        }
+      }
+    }
+
+    // Resolve all context values that might be Promises or SafeStrings
+    const resolvedContext = {};
+    if (context && typeof context === 'object') {
+      const keys = typeof context[Symbol.iterator] === 'function' ? [] : Object.keys(context);
+      // Also try to get keys from proxy
+      try {
+        for (const key of Reflect.ownKeys(context)) {
+          if (typeof key === 'string') keys.push(key);
+        }
+      } catch (e) {
+        // Not a proxy or ownKeys not supported
+      }
+      const uniqueKeys = [...new Set(keys)];
+      for (const key of uniqueKeys) {
+        try {
+          let val = context[key];
+          val = await Promise.resolve(val);
+          if (val instanceof SafeString) {
+            resolvedContext[key] = val.toString();
+          } else if (val && typeof val === 'object' && val.string !== undefined) {
+            resolvedContext[key] = val.string;
+          } else {
+            resolvedContext[key] = val;
+          }
+        } catch (e) {
+          resolvedContext[key] = '';
+        }
+      }
+    }
+
+    // Use Mustache to render the remaining template (simple {{variable}} replacements)
+    // Disable HTML escaping since we handle SafeString ourselves
+    return Mustache.render(processed, resolvedContext);
+  };
+}
+
+export const asyncHandlebars = {
+  compile,
+  SafeString,
+  registerHelper(name, fn) {
+    _helpers[name] = fn;
+  },
+};
 
 //# sourceMappingURL=asyncHandlebars.js.map
